#!/usr/bin/env python3
import os, html, asyncio, io, subprocess, re
from xmlrpc.client import ServerProxy, Fault, ProtocolError
from fastapi import FastAPI, HTTPException, Depends, Query
from fastapi.responses import (
    HTMLResponse, RedirectResponse, PlainTextResponse,
    StreamingResponse, FileResponse, JSONResponse
)
from fastapi.security import HTTPBasic, HTTPBasicCredentials

APP_TITLE = "Py Runner"
security = HTTPBasic()

SUP_USER = os.environ.get("SUPERVISOR_USER", "admin")
SUP_PASS = os.environ.get("SUPERVISOR_PASSWORD", "admin")
SUP_URL  = os.environ.get("SUPERVISOR_URL", "http://127.0.0.1:9001/RPC2")
LOGS_DIR = os.environ.get("LOGS_DIR", "/workspace/logs")
CONF_DIR = os.environ.get("CONF_DIR", "/etc/supervisor/conf.d")

# ---------- SSE (cambios de scripts)
subscribers: set[asyncio.Queue] = set()
def publish(msg: str):
    for q in list(subscribers):
        try: q.put_nowait(msg)
        except Exception: pass

def get_rpc():
    from urllib.parse import urlparse, urlunparse
    u = urlparse(SUP_URL)
    netloc = f"{SUP_USER}:{SUP_PASS}@{u.hostname}:{u.port or 9001}"
    return ServerProxy(urlunparse((u.scheme, netloc, u.path or "/RPC2", "", "", "")), allow_none=True)

def auth(credentials: HTTPBasicCredentials = Depends(security)):
    if credentials.username == SUP_USER and credentials.password == SUP_PASS:
        return True
    raise HTTPException(status_code=401, detail="Unauthorized")

# ---------- Tail EFICIENTE
def tail_last_n_lines(path: str, n: int = 300, block_size: int = 8192):
    if not os.path.exists(path):
        return "", 0
    size = os.path.getsize(path)
    if size == 0:
        return "", 0
    with open(path, "rb") as f:
        remaining = size
        chunks = []
        lines_found = 0
        while remaining > 0 and lines_found <= n:
            to_read = min(block_size, remaining)
            remaining -= to_read
            f.seek(remaining)
            chunk = f.read(to_read)
            chunks.insert(0, chunk)
            lines_found = b"".join(chunks).count(b"\n")
        data = b"".join(chunks)
    lines = data.splitlines()[-n:]
    text = "\n".join(l.decode("utf-8", "replace") for l in lines)
    return text, size

# ---------- Helpers AUTOSTART (robustos por regex, sin excepciones)
def _ini_path(name: str) -> str:
    return os.path.join(CONF_DIR, f"{name}.ini")

_section_re_tpl = r"(?ms)^\s*\[program:{name}\]\s*(?P<body>.*?)(?=^\s*\[program:|\Z)"

def _read_ini_text(path: str) -> str | None:
    try:
        with open(path, "r", encoding="utf-8", errors="replace") as f:
            return f.read()
    except Exception:
        return None

def get_autostart(name: str):
    """True/False si es .ini autogenerado; None si no aplica o no se puede determinar."""
    path = _ini_path(name)
    txt = _read_ini_text(path)
    if not txt:
        return None
    if "AUTOGENERATED_BY_PY_RUNNER" not in txt:
        return None  # no administrado por py-manager
    # Busca SOLO dentro de [program:name]
    pat = _section_re_tpl.format(name=re.escape(name))
    m = re.search(pat, txt)
    body = m.group("body") if m else txt
    m2 = re.search(r"(?mi)^\s*autostart\s*=\s*(\S+)", body)
    if not m2:
        return False
    val = m2.group(1).strip().lower()
    return val in ("1", "true", "yes", "on")

def set_autostart(name: str, value: bool):
    path = _ini_path(name)
    txt = _read_ini_text(path)
    if txt is None:
        raise HTTPException(404, "No existe el .ini del script")
    if "AUTOGENERATED_BY_PY_RUNNER" not in txt:
        raise HTTPException(400, "Este proceso no es administrado por py-manager")

    pat = _section_re_tpl.format(name=re.escape(name))
    m = re.search(pat, txt)
    if not m:
        # No sección: no reventamos; añadimos la línea al final de archivo
        new_txt = txt + ("" if txt.endswith("\n") else "\n") + f"[program:{name}]\nautostart={'true' if value else 'false'}\n"
    else:
        start, end = m.span("body")
        body = txt[start:end]
        if re.search(r"(?mi)^\s*autostart\s*=", body):
            body_new = re.sub(r"(?mi)^\s*autostart\s*=.*$", f"autostart={'true' if value else 'false'}", body)
        else:
            # Insertamos al final del body con salto de línea si hace falta
            sep = "" if body.endswith("\n") else "\n"
            body_new = body + f"{sep}autostart={'true' if value else 'false'}\n"
        new_txt = txt[:start] + body_new + txt[end:]

    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(new_txt)
    except Exception as e:
        raise HTTPException(500, f"No se pudo escribir INI: {e}")

    # Reread/update sin romper
    subprocess.run(["supervisorctl", "reread"], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(["supervisorctl", "update"], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# ---------- UI helpers
def traffic_dot(state: str) -> str:
    s = (state or "").upper()
    color = {
        "RUNNING": "bg-emerald-400 ring-1 ring-emerald-500/40",
        "STOPPED": "bg-slate-400 ring-1 ring-slate-500/40",
        "STARTING":"bg-blue-400 ring-1 ring-blue-500/40",
        "STOPPING":"bg-amber-400 ring-1 ring-amber-500/40",
        "EXITED":  "bg-rose-400 ring-1 ring-rose-500/40",
        "FATAL":   "bg-rose-500 ring-1 ring-rose-600/50",
        "BACKOFF": "bg-orange-400 ring-1 ring-orange-500/40",
    }.get(s, "bg-slate-400 ring-1 ring-slate-500/40")
    return f'<span class="inline-block h-2.5 w-2.5 rounded-full {color} mr-2"></span>'

def state_chip(state: str) -> str:
    s = (state or "").upper()
    base = "px-2 py-0.5 rounded-md text-xs font-medium inline-flex items-center ring-1"
    cls = {
        "RUNNING": f"{base} bg-emerald-900/30 text-emerald-200 ring-emerald-700/30",
        "STOPPED": f"{base} bg-slate-900/40 text-slate-300 ring-slate-700/30",
        "STARTING":f"{base} bg-blue-900/30 text-blue-200 ring-blue-700/30",
        "STOPPING":f"{base} bg-amber-900/30 text-amber-200 ring-amber-700/30",
        "EXITED":  f"{base} bg-rose-900/30 text-rose-200 ring-rose-700/30",
        "FATAL":   f"{base} bg-rose-900/50 text-rose-100 ring-rose-800/40",
        "BACKOFF": f"{base} bg-orange-900/30 text-orange-200 ring-orange-700/30",
    }.get(s, f"{base} bg-slate-900/40 text-slate-300 ring-slate-700/30")
    return f'<span class="{cls}">{traffic_dot(s)}{html.escape(s)}</span>'

def buttons_html(name: str, state: str, autostart_value):
    running = (state or "").upper() == "RUNNING"
    start_active = not running
    stop_active  = running

    btn = "px-3 py-1 rounded-lg transition border ring-1"
    start_cls = (f"{btn} {('bg-emerald-600 text-white border-emerald-700 ring-emerald-800/40 hover:bg-emerald-500') if start_active else 'bg-emerald-600/15 text-emerald-200 border-emerald-800/50 ring-emerald-900/30 cursor-not-allowed pointer-events-none'}")
    stop_cls  = (f"{btn} {('bg-rose-600 text-white border-rose-700 ring-rose-800/40 hover:bg-rose-500') if stop_active else 'bg-rose-600/15 text-rose-200 border-rose-800/50 ring-rose-900/30 cursor-not-allowed pointer-events-none'}")
    restart_cls = f"{btn} bg-indigo-600/90 text-white border-indigo-700 ring-indigo-800/40 hover:bg-indigo-500"
    logs_cls    = f"{btn} bg-slate-700/70 text-slate-100 border-slate-600 ring-slate-700/40 hover:bg-slate-600/70"
    dl_cls      = f"{btn} bg-teal-700/80 text-white border-teal-800 ring-teal-900/30 hover:bg-teal-600/80"

    chk_html = ""
    if autostart_value is not None:
        chk = "checked" if autostart_value else ""
        chk_html = f"""
        <label class="ml-3 inline-flex items-center gap-2 text-xs text-slate-300">
          <input type="checkbox" class="h-4 w-4 rounded bg-slate-800 border-slate-600"
                 data-name="{html.escape(name)}" {chk}
                 onclick="toggleAutoStart(this)">
          Siempre
        </label>"""

    return f"""
    <div class="flex items-center gap-3">
      <div class="inline-flex items-center gap-2 bg-slate-900/40 border border-slate-700/50 ring-1 ring-white/5 rounded-xl px-2 py-1 shadow-sm">
        <a class="{start_cls}" href="/action/start?name={html.escape(name)}">Start</a>
        <a class="{stop_cls}"  href="/action/stop?name={html.escape(name)}">Stop</a>
      </div>
      <div class="h-6 w-px bg-slate-700/40"></div>
      <div class="inline-flex items-center gap-2">
        <a class="{restart_cls}" href="/action/restart?name={html.escape(name)}">Restart</a>
        <a class="{logs_cls}" href="/logs/{html.escape(name)}?stream=stdout">Logs</a>
        <a class="{dl_cls}"  href="/logs/download?name={html.escape(name)}&stream=stdout">Descargar</a>
        {chk_html}
      </div>
    </div>
    """

# ---------- FastAPI app
app = FastAPI(title=APP_TITLE)

HTML_HEAD = f"""<!doctype html>
<html lang="es"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Py Runner</title>
<script src="https://cdn.tailwindcss.com"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {{
  const es = new EventSource('/events');
  es.onmessage = (ev) => {{ if (ev.data === 'scripts_changed') location.reload(); }};
}});

function toggleAutoStart(el) {{
  const name = el.getAttribute('data-name');
  const value = el.checked ? 'true' : 'false';
  el.disabled = true;
  fetch(`/api/autostart?name=${{encodeURIComponent(name)}}&value=${{value}}`, {{ method: 'POST' }})
    .then(r => r.ok ? r.json() : Promise.reject())
    .catch(() => {{ el.checked = !el.checked; }})
    .finally(() => {{ el.disabled = false; }});
}}
</script>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-800 text-slate-100">
<div class="max-w-7xl mx-auto p-6">

  <!-- CABECERA alineada con la tabla -->
  <header class="mb-6">
    <div class="max-w-6xl mx-auto flex items-center gap-3">
      <a href="/?show=user" class="px-3 py-1.5 rounded-full bg-slate-700/70 text-slate-100 border border-slate-600 ring-1 ring-white/5 hover:bg-slate-600/70">Home</a>
      <h1 class="text-3xl font-semibold tracking-tight">Zenoverso Python Scripts <span class="text-sm text-slate-400 align-middle">(UI)</span></h1>
      <span class="text-sm text-slate-400"></span>
    </div>
  </header>
"""

HTML_FOOT = """</div></body></html>"""

@app.get("/__health", response_class=PlainTextResponse)
def health(): return "ok"

@app.get("/events")
async def events(_: bool = Depends(auth)):
    q: asyncio.Queue = asyncio.Queue()
    subscribers.add(q)
    async def gen():
        try:
            while True:
                msg = await q.get()
                yield f"data: {msg}\\n\\n"
        finally:
            subscribers.discard(q)
    return StreamingResponse(gen(), media_type="text/event-stream")

@app.get("/api/notify", response_class=PlainTextResponse)
def notify(what: str = "scripts_changed", _: bool = Depends(auth)):
    publish(what); return "ok"

# ---------- API autostart
@app.post("/api/autostart")
def api_autostart(name: str = Query(..., min_length=1),
                  value: bool = Query(...),
                  _: bool = Depends(auth)):
    set_autostart(name, value)
    return {"ok": True, "name": name, "autostart": value}

# ---------- Pantalla principal (por defecto: sólo scripts)
@app.get("/", response_class=HTMLResponse)
def home(_: bool = Depends(auth), show: str = Query("user", pattern="^(user|all)$")):
    rpc = get_rpc()
    try:
        procs = rpc.supervisor.getAllProcessInfo()
    except (Fault, ProtocolError) as e:
        raise HTTPException(500, f"Supervisor RPC error: {e}")

    if show == "user":
        hide = {"cron","py-autoreg","py-ui"}
        procs = [p for p in procs if p["name"] not in hide]

    procs = sorted(procs, key=lambda p: p["name"].lower())

    rows = []
    for p in procs:
        name = p["name"]
        state = p["statename"]
        desc = html.escape(p.get("description","")) or "&nbsp;"
        autostart_val = get_autostart(name)  # True/False/None
        rows.append(f"""
<tr class="hover:bg-slate-800/50 transition">
  <td class="py-3 px-4 font-medium text-slate-100 whitespace-nowrap">{html.escape(name)}</td>
  <td class="py-3 px-4 whitespace-nowrap">{state_chip(state)}</td>
  <td class="py-3 px-4 text-xs text-slate-300">{desc}</td>
  <td class="py-3 px-4">{buttons_html(name, state, autostart_val)}</td>
</tr>""")

    toggle = ('<a class="px-3 py-1.5 rounded-full bg-slate-700/70 text-slate-100 border border-slate-600 ring-1 ring-white/5 hover:bg-slate-600/70" href="/?show=all">Ver todos</a>'
              if show=="user" else
              '<a class="px-3 py-1.5 rounded-full bg-slate-700/70 text-slate-100 border border-slate-600 ring-1 ring-white/5 hover:bg-slate-600/70" href="/?show=user">Sólo scripts</a>')

    table = f"""
<div class="overflow-x-auto">
  <div class="inline-block align-middle w-full">
    <div class="mx-auto bg-slate-800/60 backdrop-blur-sm rounded-2xl ring-1 ring-white/5 shadow-xl overflow-hidden max-w-6xl border border-slate-700/40">
      <table class="w-full table-fixed text-sm">
        <colgroup>
          <col class="w-44"/><col class="w-40"/><col/><col class="w-[34rem]"/>
        </colgroup>
        <thead class="bg-slate-800/80 text-slate-300">
          <tr>
            <th class="py-3 px-4 text-left font-semibold">Script</th>
            <th class="py-3 px-4 text-left font-semibold">Estado</th>
            <th class="py-3 px-4 text-left font-semibold">Descripción</th>
            <th class="py-3 px-4 text-left font-semibold">Acciones</th>
          </tr>
        </thead>
        <tbody class="divide-y divide-slate-700/40">
          {"".join(rows) if rows else '<tr><td class="p-6 text-slate-300" colspan="4">No hay procesos.</td></tr>'}
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- CONTROLES INFERIORES alineados con la tabla -->
<div class="mt-5 max-w-6xl mx-auto flex justify-start gap-3">
  <a class="px-3 py-1.5 rounded-full bg-slate-700/70 text-slate-100 border border-slate-600 ring-1 ring-white/5 hover:bg-slate-600/70" href="{"/?show="+show}">Refrescar</a>
  {toggle}
</div>
"""
    return HTML_HEAD + table + HTML_FOOT

# ---------- Acciones
def _rpc_action(name: str, op: str):
    rpc = get_rpc()
    try:
        if op == "start":   rpc.supervisor.startProcess(name)
        elif op == "stop":  rpc.supervisor.stopProcess(name)
        elif op == "restart":
            try: rpc.supervisor.stopProcess(name)
            finally: rpc.supervisor.startProcess(name)
        else: raise HTTPException(400, "Operación no válida")
    except Fault as e:
        raise HTTPException(400, f"RPC error: {e.faultString}")

@app.get("/action/start")
def do_start(name: str = Query(..., min_length=1), _: bool = Depends(auth)):
    _rpc_action(name, "start"); return RedirectResponse("/", status_code=303)

@app.get("/action/stop")
def do_stop(name: str = Query(..., min_length=1), _: bool = Depends(auth)):
    _rpc_action(name, "stop"); return RedirectResponse("/", status_code=303)

@app.get("/action/restart")
def do_restart(name: str = Query(..., min_length=1), _: bool = Depends(auth)):
    _rpc_action(name, "restart"); return RedirectResponse("/", status_code=303)

# ---------- Descarga de log completo
@app.get("/logs/download")
def download_log(name: str = Query(...), stream: str = Query("stdout"), _: bool = Depends(auth)):
    ext = "err" if stream.lower()=="stderr" else "out"
    path = os.path.join(LOGS_DIR, f"{name}.{ext}.log")
    if not os.path.exists(path): raise HTTPException(404, "No existe el log")
    return FileResponse(path, filename=f"{name}.{ext}.log", media_type="text/plain")

# ---------- API: tail inicial
@app.get("/api/logs/tail")
def api_tail(name: str, stream: str = "stdout", n: int = 300, _: bool = Depends(auth)):
    ext = "err" if stream.lower()=="stderr" else "out"
    path = os.path.join(LOGS_DIR, f"{name}.{ext}.log")
    text, pos = tail_last_n_lines(path, max(1, min(n, 2000)))
    return JSONResponse({"text": text, "pos": pos, "path": path})

# ---------- SSE: seguimiento en vivo
@app.get("/events/log")
async def log_events(name: str, stream: str = "stdout", pos: int = 0, _: bool = Depends(auth)):
    ext = "err" if stream.lower()=="stderr" else "out"
    path = os.path.join(LOGS_DIR, f"{name}.{ext}.log")
    async def gen():
        last = max(0, pos)
        while True:
            try:
                size = os.path.getsize(path)
                if size < last:
                    last = 0
                if size > last:
                    with open(path, "r", encoding="utf-8", errors="replace") as f:
                        f.seek(last)
                        chunk = f.read(size - last)
                    last = size
                    for line in chunk.splitlines():
                        yield f"data: {line}\\n\\n"
            except FileNotFoundError:
                pass
            await asyncio.sleep(0.3)
    return StreamingResponse(gen(), media_type="text/event-stream")

# ---------- Vista de logs
@app.get("/logs/{name}", response_class=HTMLResponse)
def show_logs(name: str, stream: str = "stdout", _: bool = Depends(auth)):
    stream = "stderr" if stream.lower()=="stderr" else "stdout"
    switch = "stderr" if stream=="stdout" else "stdout"
    switch_url = f"/logs/{name}?stream={switch}"
    body = f"""
<div class="max-w-6xl mx-auto bg-slate-800/60 backdrop-blur-sm rounded-2xl ring-1 ring-white/5 shadow-xl p-5 border border-slate-700/40">
  <div class="flex items-center justify-between">
    <div>
      <h2 class="text-lg font-semibold">Logs: {html.escape(name)} <span class="text-slate-400 text-sm">({stream})</span></h2>
      <div id="log-path" class="text-xs text-slate-400 mt-1"></div>
    </div>
    <div class="space-x-2">
      <a class="px-3 py-1 rounded-lg bg-slate-700/80 text-slate-100 border border-slate-600 ring-1 ring-white/5 hover:bg-slate-600/80 transition" href="{switch_url}">Ver {switch}</a>
      <a class="px-3 py-1 rounded-lg bg-teal-700/80 text-white border border-teal-800 ring-1 ring-teal-900/30 hover:bg-teal-600/80 transition" href="/logs/download?name={html.escape(name)}&stream={stream}">Descargar</a>
      <button id="btn-clear" class="px-3 py-1 rounded-lg bg-amber-500/90 text-black border border-amber-600 ring-1 ring-amber-300/60 hover:bg-amber-400 transition">Clear</button>
    </div>
  </div>
  <pre id="logbox" class="mt-3 text-xs bg-slate-950 text-slate-100 p-4 rounded-xl overflow-auto max-h-[70vh] whitespace-pre-wrap"></pre>
</div>

<script>
(async () => {{
  const NAME = {name!r};
  const STREAM = {stream!r};
  const box = document.getElementById('logbox');
  const btnClear = document.getElementById('btn-clear');
  const pathEl = document.getElementById('log-path');

  let buf = [];
  const MAX = 300;

  let dirty = false;
  function schedulePaint() {{
    if (dirty) return;
    dirty = true;
    setTimeout(() => {{
      box.textContent = buf.join('\\n');
      box.scrollTop = box.scrollHeight;
      dirty = false;
    }}, 200);
  }}

  btnClear.addEventListener('click', () => {{
    buf = [];
    schedulePaint();
  }});

  const r = await fetch(`/api/logs/tail?name=${{encodeURIComponent(NAME)}}&stream=${{STREAM}}&n=${{MAX}}`);
  const j = await r.json();
  pathEl.textContent = j.path;
  if (j.text) {{
    buf = j.text.split('\\n').slice(-MAX);
    schedulePaint();
  }}
  let pos = j.pos || 0;

  const es = new EventSource(`/events/log?name=${{encodeURIComponent(NAME)}}&stream=${{STREAM}}&pos=${{pos}}`);
  es.onmessage = (ev) => {{
    if (!ev.data) return;
    buf.push(ev.data);
    if (buf.length > MAX) buf.splice(0, buf.length - MAX);
    schedulePaint();
  }};
}})();
</script>
"""
    return HTML_HEAD + body + HTML_FOOT
